

'''
Il y a 2 options possibles:
1. La reference est un genome compltet => path est donc  typing/gatk_gvcfs/full_genome_{ref}/bwa/all_samples_snp.vcf
2. La référence est un cgMLST ou un parsnp core genome => path est donc  typing/gatk_gvcfs/cgMLST/bwa/all_samples_snp.vcf

Comme "full_genome_" peut être présent ou non, on ne peut pas capturer cette info dans une unique règle, à moins de rajouter
une variable dans tous les path:

- typing/gatk_gvcfs/full_genome/<sample_222>_assembled_genome/...
- typing/gatk_gvcfs/core_genome/cgMLST/...
- typing/gatk_gvcfs/core_genome/parsnp/...
'''


def gbk_ref(wildcards):
    '''
    Handle various possible references:
        - cgMLST (downloaded gbk reformated for IGV)
        - assembled genome (gbk generated by prokka)
        - NCBI genome (downloaded gbk)
    '''
    # assembled genome
    if "_assembled_genome" in wildcards.reference:
        print("GBK: assembled reference")
        return "references/" + wildcards.reference + "/genome_filtered.gbk"
    # cgMLST
    elif wildcards.reference == "cgMLST":
        print("GBK: cgMLST")
        return "references/" + str(all_core_genome_dbs.loc[species, "ReferenceGenome"]) + "/genome_gbwithparts.gbk"
    # downloaded reference genome
    else:
        "GBK: Reference from NCBI"
        return "references/" + wildcards.reference + "/genome_gbwithparts.gbk"


def vcf_ref(wildcards):
    # typing/gatk_gvcfs/full_genome_79781/bwa/filtering/freq_cov_decomposed_normalized.vcf
    if "_assembled_genome" in wildcards.reference:
        print("VCF: assembled genomes")
        return "typing/" + wildcards.snp_caller + "/full_genome_" + wildcards.reference + "/" + wildcards.mapping_method + "/filtering/freq_cov_decomposed_normalized.vcf"
    elif "cgMLST" in wildcards.reference:
        print("VCF: cgMLST")
        return "typing/" + wildcards.snp_caller + "/full_genome_" + str(all_core_genome_dbs.loc[species, "ReferenceGenome"]) + "/" + wildcards.mapping_method + "/filtering/freq_cov_decomposed_normalized.vcf"
    elif "parsnp" in wildcards.reference:
        print("VCF: parsnp")
        return "typing/" + wildcards.snp_caller + "/" + wildcards.reference + "/" + wildcards.mapping_method + "/filtering/freq_cov_decomposed_normalized.vcf"
    else:
        print("VCF: NCBI reference")
        # NCBI reference?
        return "typing/" + wildcards.snp_caller + "/full_genome_" + wildcards.reference + "/" + wildcards.mapping_method + "/filtering/freq_cov_decomposed_normalized.vcf"
        #raise IOError("wrong reference")

rule generate_snps_html_report:
    conda:
        "../../envs/python-r.yml"
    container:
        containers["python_r"]
    input:
        # samples/TATRas-control/snps/gatk_gvcfs/TATRas-control_assembled_genome/bwa/freq.vcf
        # typing/gatk_gvcfs/full_genome_TATRas-control_assembled_genome/bwa/all_samples_snp.vcf
        vcf_file = "samples/{sample}/snps/{snp_caller}/{reference}/{mapping_method}/freq.vcf",
        merged_vcf = vcf_ref,
        gbk_file = gbk_ref
    params:
        reference = lambda wildcards: wildcards.reference
    output:
        #  report/snps/cgMLST/bwa/gatk_gvcfs/TATRas-control.html
        html_file = "report/snps/{reference}/{mapping_method}/{snp_caller}/{sample}.html"

    script: "scripts/snps_reports.py"

rule generate_deletion_html_report:
    conda:
        "../../envs/python-r.yml"
    container:
        containers["python_r"]
    input:
        deletion_bed = "samples/{sample}/indel/{mapping_method}/{reference}/indel.bed",
        gbk_file = gbk_ref
    output:
        report_file = "report/indel/{reference}/{mapping_method}/{sample}.html"
    script: "scripts/indel_reports.py"
